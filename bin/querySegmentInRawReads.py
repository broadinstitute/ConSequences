#!/usr/bin/env python

### Program: querySegmentInRawReads.py
### Author: Rauf Salamzade
### The Broad Institute of MIT and Harvard
### Earl Lab / Bacterial Genomics Group

"""
Special thanks to Terrance Shea and Bruce Walker for extensive feedback and suggestions.
"""
import os
import sys
import argparse
import subprocess
from ConSequences import ConSequences

def create_parser():
	""" Parse arguments """
	parser = argparse.ArgumentParser(description="""
	Program: generateReferenceMSA.py
	Author: Rauf Salamzade
	The Broad Institute of MIT and Harvard
	Earl Lab / Bacterial Genomics Group

	This program will use a segment MSA(s) (as generated by generateReferenceMSA.py) and check if some sample's raw sequencing data
	shows signs of having the assembly path for the segment. If facing difficulties, please raise issues on the github page:
	https://github.com/broadinstitute/consequences
	""", formatter_class=argparse.RawTextHelpFormatter)
	parser.add_argument('-m', '--ref_msas', nargs='+', help="Multi-FASTA reference-based multiple sequence alignment(s) for segment(s) of interest.", required=True)
	parser.add_argument('-r', '--references', nargs='+', help="Reference sample. Should be provided in same respective order as --ref_msas.", required=True)
	parser.add_argument('-i', '--illumina_reads', nargs='+',  help="Illumina or any high-accuracy sequencing data in FASTQ format.", required=True)
	parser.add_argument('-o', '--output_prefix', type=str, help="Output prefix", required=True)
	parser.add_argument('-d', '--min_depth', help="Minimum number of times k-mer has to occur in sample read's to avoid inclusion of sequencing errors.", required=False, default=5)
	parser.add_argument('-k', '--kmer_length', type=int, help="Size of k-mer to use for searching. Default is 31.", required=False, default=31)
	parser.add_argument('-c', '--cores', type=int, help="Number of cores to provide JellyFish. Default is 1.", required=False, default=1)
	args = parser.parse_args()
	return args

def main():
	"""
	Void function which runs primary workflow for program.
	"""

	"""
	PARSE REQUIRED INPUTS
	"""

	myargs = create_parser()

	ref_msa_files = [os.path.abspath(f) for f in myargs.ref_msas]
	reference_scaffolds = myargs.references
	illumina_read_files = [os.path.abspath(f) for f in myargs.illumina_reads]
	output_prefix = myargs.output_prefix
	min_depth = int(myargs.min_depth)
	kmer_length = int(myargs.kmer_length)
	cores = int(myargs.cores)

	try:
		for ref_msa_file in ref_msa_files:
			assert(ConSequences.is_fasta(ref_msa_file))
			for f in illumina_read_files:
				assert(os.path.isfile(f))
	except:
		raise RuntimeError("Reference FASTA or Sliding-Window Results file(s) are invalid. Raising error.")


	"""
	START WORKFLOW
	"""

	# Step 0: Log input arguments and update reference and query FASTA files.
	sys.stderr.write("Parameters Used:\n")
	parameter_values = [' ;'.join(ref_msa_files), ' ;'.join(reference_scaffolds), '; '.join(illumina_read_files), output_prefix, min_depth, kmer_length, cores]
	parameter_names = ["Reference MSA file", "Reference scaffolds", "Illumina sequencing reads", "Result prefix", "Minimum K-mer Depth", "K-mer length", "Cores"]
	ConSequences.logParameters(parameter_names, parameter_values)

	# Step 1: K-merize MSA and get universe of relevant k-mers
	sys.stderr.write("K-merize segment MSAs.")
	tot_msa_kmers = set([])
	seg_data = []
	for i, ref_msa_file in enumerate(ref_msa_files):
		reference_scaffold = reference_scaffolds[i]
		ref_seg_seq, motif_msa, msa_kmers = ConSequences.kmerize_msa(ref_msa_file, reference_scaffold, kmer_length)
		tot_msa_kmers = tot_msa_kmers.union(msa_kmers)
		seg_data.append([ref_seg_seq, motif_msa])
	sys.stderr.write("Successfully k-merized MSAs.\n")

	# Step 2: K-merize sequencing reads for sample and grab relevant k-mers
	sys.stderr.write("K-merize sample's sequencing reads.\n")
	sample_kmers = ConSequences.kmerize_reads(illumina_read_files, output_prefix, min_depth, kmer_length, tot_msa_kmers, cores)
	sys.stderr.write("Successfully k-merized sample's sequencing reads.\n")

	# Step 3: Search sample's k-merome for segment assembly path.
	sys.stderr.write("Searching sample's k-merome for segment assembly path .\n")

	output_handle = open(output_prefix + '_results.txt', 'w')
	output_handle.write("Reference MSA\tTotal k-mers missed\tTotal k-mers missed (ignoring starting/ending 100 bp of MSA)\tNumber of k-mers assessed\n")
	output_handle.close()

	for i, ref_msa_file in enumerate(ref_msa_files):
		ref_seg_seq, motif_msa = seg_data[i]
		ConSequences.check_if_sample_has_segment(ref_msa_file, ref_seg_seq, motif_msa, sample_kmers, kmer_length, output_prefix)
	sys.stderr.write("Successfully assessed presence of segment in sample's sequencing data.\n")

	# Step 4: Perform cleanup of temporary files.
	os.system("rm -f %s %s" % (output_prefix + ".kmers.tab", output_prefix + ".jf" ))

	sys.stderr.write("Program successfully ran! Exiting!\n")
	sys.exit(0)

main()
